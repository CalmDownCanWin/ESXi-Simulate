import ESXi_fs as fs
import ESXi_command as  cmd
import re
import time 
import random
from test_esxcli import handle_namespace as handle_esxcli_namespace
from test_vimcmd import ESXiVimCmdCommand
from test_vmdumper import ESXiVmdumperCommand


# Dictionary ánh xạ pattern với handler và arguments
PYTHON_COMMAND_PATTERNS = {
    r"esxcli vm process list": (handle_esxcli_namespace, ["vm", "process", "list"]),
    r"esxcli vm process kill ": (handle_esxcli_namespace, ["vm", "process", "kill"]),
    r"vim-cmd vmsvc/power.off (\d+)": (ESXiVimCmdCommand, ["vmsvc/", "power.off"]),
    r"vmdumper -l": (ESXiVmdumperCommand, ["-l"]),
    # Thêm các pattern và handler khác vào đây
}


class ESXiPythonCommand(cmd.SimpleCommand):
    """
    Lệnh python mô phỏng cho honeypot ESXi.
    """
    def run(self):
        # Xử lý option -h, --help, -V, --version
        if any(opt in self.args for opt in ["-h", "--help", "-V", "--version"]):
            self.show_help()
            return

        # Xử lý option -c
        if "-c" in self.args:
            try:
                code_index = self.args.index("-c") + 1
                code = self.args[code_index]
                # Mô phỏng thực thi code Python (không thực sự thực thi)
                self.write_output(f"Executing Python code: {code}\n")
            except IndexError:
                self.stderr = "python: -c option requires argument"
                self.returncode = 2
                return

        # Xử lý file script
        elif len(self.args) > 0:
            filename = self.args[0]
            filepath = self.fs.resolve_path(filename)
            if not self.fs.isfile(filepath):
                self.stderr = f"python: can't open file '{filename}': [Errno 2] No such file or directory"
                self.returncode = 2
                return
            # Mô phỏng thực thi file script (không thực sự thực thi)
            #self.write_output(f"Executing Python script: {filename}\n")
            try:
                with self.fs.open(filepath, "r") as f:
                    script = f.read()

                # Phân tích và mô phỏng script
                self.analyze_and_execute(script) 

            except (fs.FileNotFoundError, PermissionError) as e:
                self.stderr = f"python {filepath}: {e}"
                self.returncode = 1

        # Chế độ interactive
        else:
            self.write_output("Python 3.5.2 (default, Nov 17 2016, 17:05:23)\r\n")
            self.write_output("[GCC 5.4.0 20160609] on linux\r\n")
            self.write_output("Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n")
            self.write_output(">>> \r")

    def analyze_and_execute(self, script):
        """
        Phân tích script Python và thực thi mô phỏng.
        """
        found_command = False

        for pattern, (handler, handler_args) in PYTHON_COMMAND_PATTERNS.items():
            match = re.search(pattern, script)
            if match:
                found_command = True
                # Nếu regex có group, truyền giá trị group cho handler
                if match.groups():
                    handler(self,self.fs, *handler_args, *match.groups())
                else:
                    handler(self,self.fs, *handler_args)

        if not found_command:
            self.handle_uncommon_behavior()

    def handle_uncommon_behavior(self):
        """Xử lý hành vi độc hại (không khớp pattern)."""
        delay = random.randint(2, 5)
        self.write_output("Executing script...\n")
        time.sleep(delay)
        self.write_output("Done.\n")
        self.handle_CTRL_C()  # Ngắt kết nối

    def show_help(self):
        """
        Hiển thị thông tin trợ giúp.
        """
        self.write_output(
            """usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-b     : issue warnings about str(bytes_instance), str(bytearray_instance)
         and comparing bytes/bytearray with str. (-bb: issue errors)
-B     : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x
-c cmd : program passed in as string (terminates option list)
-d     : debug output from parser; also PYTHONDEBUG=x
-E     : ignore PYTHON* environment variables (such as PYTHONPATH)
-h     : print this help message and exit (also --help)
-i     : inspect interactively after running script; forces a prompt even
         if stdin does not appear to be a terminal; also PYTHONINSPECT=x
-I     : isolate Python from the user's environment (implies -E and -s)
-m mod : run library module as a script (terminates option list)
-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x
-OO    : remove doc-strings in addition to the -O optimizations
-q     : don't print version and copyright messages on interactive startup
-s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE
-S     : don't imply 'import site' on initialization
-u     : unbuffered binary stdout and stderr, stdin always buffered;
         also PYTHONUNBUFFERED=x
         see man page for details on internal buffering relating to '-u'
-v     : verbose (trace import statements); also PYTHONVERBOSE=x
         can be supplied multiple times to increase verbosity
-V     : print the Python version number and exit (also --version)
-W arg : warning control; arg is action:message:category:module:lineno
         also PYTHONWARNINGS=arg
-x     : skip first line of source, allowing use of non-Unix forms of #!cmd
-X opt : set implementation-specific option
file   : program read from script file
-      : program read from stdin (default; interactive mode if a tty)
arg ...: arguments passed to program in sys.argv[1:]

Other environment variables:
PYTHONSTARTUP: file executed on interactive startup (no default)
PYTHONPATH   : ':'-separated list of directories prefixed to the
               default module search path.  The result is sys.path.
PYTHONHOME   : alternate <prefix> directory (or <prefix>:<exec_prefix>).
               The default module search path uses <prefix>/pythonX.X.
PYTHONCASEOK : ignore case in 'import' statements (Windows).
PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.
PYTHONFAULTHANDLER: dump the Python traceback on fatal errors.
PYTHONHASHSEED: if this variable is set to 'random', a random value is used
   to seed the hashes of str, bytes and datetime objects.  It can also be
   set to an integer in the range [0,4294967295] to get hash values with a
   predictable seed.
"""
        )
