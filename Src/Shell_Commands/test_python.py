import ESXi_fs as fs
import ESXi_command as  cmd

import re
import time 
import random
import os

import error_handler as er


# Dictionary patterns
# SUSPICIOUS_PATTERNS = [
#     # Pattern Found Behavior
#     r"esxcli\s+vm\s+process\s+kill\b",
#     r"vim-cmd\s+vmsvc/power\.(off|suspend|shutdown)\b",
#     r"vmdumper\b",
#     r"rm\s+-rf\b",
#     r"shutdown\b",
#     r"reboot\b",
#     # Pattern Found file/folder
#     r"find\s+(/.*?)\s+-name\s+\"\*?\.(.+?)\"",  # Sửa lỗi escape . và *
#     r"find\s+(/vmfs/volumes.+?)\s+(-type\s+f\s+\(.*?\)\s+-name\s+\"\*?\.(.+?)\"|-name\s+\"\*?\.(.+?)\")", 
#     r"ls\s+-R\s+(/.*?)",
#     r"dir\s+(/mfs/volumes.+?)\s+/.*-R",
    
#     # Pattern Change file ext
#     r"mv\s+\"\$i\"\s+\"\$i\.(\w+)\"",
#     r"mv\s+(.+?)\s+(.+?)\.(\w+)",  
#     r"for\s+f\s+in\s+\*; do\s+mv\s+\"\$f\"\s+\"\$f\.(\w+)\";\s+done",
#     r"for\s+i\s+in\s+\$\(find\s+.+-type\s+f\); do\s+mv\s+\"\$i\"\s+\"\$i\.(\w+)\";\s+done",
    
#     # Pattern for encryption
#     r"openssl\s+enc\s+-aes-256-cbc\s+-k\s+\"fake_key\""
# ]


class ESXiPythonCommand(cmd.SimpleCommand):
    """
    /bin/python
    """
    def run(self):
        # Help
        if any(opt in self.args for opt in ["-h", "--help"]):
            self.show_help()
            return

        # option -c
        if "-c" in self.args:
            try:
                code_index = self.args.index("-c") + 1
                code = self.args[code_index]
                self.write_output(f"Executing Python code: {code}\n")
            except IndexError:
                self.stderr = "python: -c option requires argument"
                self.returncode = 2
                return

        # Execute file
        elif len(self.args) > 0:
            filename = self.args[0]
            filepath = self.fs.resolve_path(filename)
            if not self.fs.isfile(filepath):
                self.stderr = f"python: can't open file '{filename}': [Errno 2] No such file or directory"
                self.returncode = 2
                return
            
            try:
            # Check
                if not self.fs.isfile(filepath):
                    self.stderr = f"-python: {filepath}: not found"
                    self.returncode = 127
                    return

                delay = random.uniform(3, 7) 
                time.sleep(delay) 

                # Tạo thông báo lỗi giả mạo
                self.stderr = er.Python_Interactive_Error()
                self.returncode = 1 

            except (PermissionError) as e:
                if isinstance(e, PermissionError):
                    self.stderr = er.Permission_Denied(filepath)
                    self.returncode = 1

        # Interactive mode




    def show_help(self):
        """
        Help!
        """
        self.write_output(
            """usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...\r\n
Options and arguments (and corresponding environment variables):\r\n
-b     : issue warnings about str(bytes_instance), str(bytearray_instance)\r\n
         and comparing bytes/bytearray with str. (-bb: issue errors)\r\n
-B     : don't write .pyc files on import; also PYTHONDONTWRITEBYTECODE=x\r\n
-c cmd : program passed in as string (terminates option list)\r\n
-d     : debug output from parser; also PYTHONDEBUG=x\r\n
-E     : ignore PYTHON* environment variables (such as PYTHONPATH)\r\n
-h     : print this help message and exit (also --help)\r\n
-i     : inspect interactively after running script; forces a prompt even\r\n
         if stdin does not appear to be a terminal; also PYTHONINSPECT=x\r\n
-I     : isolate Python from the user's environment (implies -E and -s)\r\n
-m mod : run library module as a script (terminates option list)\r\n
-O     : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x\r\n
-OO    : remove doc-strings in addition to the -O optimizations\r\n
-q     : don't print version and copyright messages on interactive startup\r\n
-s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE\r\n
-S     : don't imply 'import site' on initialization\r\n
-u     : unbuffered binary stdout and stderr, stdin always buffered;\r\n
         also PYTHONUNBUFFERED=\r\n
         see man page for details on internal buffering relating to '-u'\r\n
-v     : verbose (trace import statements); also PYTHONVERBOSE=x\r\n
         can be supplied multiple times to increase verbosity\r\n
-V     : print the Python version number and exit (also --version)\r\n
-W arg : warning control; arg is action:message:category:module:lineno\r\n
         also PYTHONWARNINGS=arg\r\n
-x     : skip first line of source, allowing use of non-Unix forms of #!cmd\r\n
-X opt : set implementation-specific option\r\n
file   : program read from script file\r\n
-      : program read from stdin (default; interactive mode if a tty)\r\n
arg ...: arguments passed to program in sys.argv[1:]\r\n

Other environment variables:\r\n
PYTHONSTARTUP: file executed on interactive startup (no default)\r\n
PYTHONPATH   : ':'-separated list of directories prefixed to the\r\n
               default module search path.  The result is sys.path.\r\n
PYTHONHOME   : alternate <prefix> directory (or <prefix>:<exec_prefix>).\r\n
               The default module search path uses <prefix>/pythonX.X.\r\n
PYTHONCASEOK : ignore case in 'import' statements (Windows).\r\n
PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.\r\n
PYTHONFAULTHANDLER: dump the Python traceback on fatal errors.\r\n
PYTHONHASHSEED: if this variable is set to 'random', a random value is used\r\n
   to seed the hashes of str, bytes and datetime objects.  It can also be\r\n
   set to an integer in the range [0,4294967295] to get hash values with a\r\n
   predictable seed.\r\n
"""
        )

